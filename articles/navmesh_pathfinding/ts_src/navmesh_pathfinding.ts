import { file_extension } from "./helpers";
import { GameInterface } from "./game_interface";
import { EngineAssets } from "./assets";
import { Renderer } from "./renderer";
import { EngineWebSocket, WebSocketMessage } from "./websocket";
import { set_last_error } from "./error";

class Engine {
    ws: EngineWebSocket = new EngineWebSocket();

    game: GameInterface = new GameInterface();
    assets: EngineAssets = new EngineAssets();
    renderer: Renderer = new Renderer();

    reload_client: boolean = false;
    reload: boolean = false;
    exit: boolean = false;
}

//
// Init
//

async function init(): Promise<Engine | null> {
    const app = new Engine();

    if (!app.renderer.init()) {
        return null;
    }

    let init_client = app.game.init();
    let init_assets = app.assets.init();
    let [client_ok, assets_ok] = await Promise.all([init_client, init_assets]);
    if (!client_ok || !assets_ok) {
        return null;
    }

    if (!app.renderer.init_default_resources(app.assets)) {
        return null;
    }
    
    if (!app.game.start(app.assets)) {
        return null;
    }

    app.ws.open();

    return app;
}

//
// Updates
//

function on_file_changed(engine: Engine, message: WebSocketMessage) {
    // Reloading is async so we don't execute it right away in the game loop.
    // See the `reload` function in this file
    const ext = file_extension(message.data);
    switch (ext) {
        case "wasm": {
            engine.reload_client = true;
            engine.reload = true;
            break;
        }
    }
}

/// Handle the updates received from the development server
function websocket_messages(engine: Engine) {
    const ws = engine.ws;
    if (!ws.open) {
        // We're using a static client with no dev server
        return;
    }

    for (let i=0; i<ws.messages_count; i++) {
        let message = ws.messages[i];
        switch (message.name) {
            case "FILE_CHANGED": {
                on_file_changed(engine, message);
                break;
            }
            default: {
                console.log("Unknown message:", message);
            }
        }
    }

    ws.messages_count = 0;
}

/// Check if the canvas size changed since the last call, and if so run the on resize logic
function handle_resize(engine: Engine) {
    engine.renderer.handle_resize()
}

/// Execute the game logic of the client for the current frame
function game_updates(engine: Engine, time: DOMHighResTimeStamp) {
    engine.game.instance.update(time)
}

/// Reads the rendering updates generated by the game client
function renderer_updates(engine: Engine) {
    engine.renderer.update(engine.game);
}

function update(engine: Engine, time: DOMHighResTimeStamp) {
    websocket_messages(engine);
    handle_resize(engine);
    game_updates(engine, time);
    renderer_updates(engine);
}

//
// Render
//

function render(engine: Engine) {
    engine.renderer.render();
}

//
// Reload
//

async function reload(engine: Engine) {
    if (engine.reload_client) {
        const reloaded = await engine.game.reload();
        if (!reloaded) {
            set_last_error("Failed to reload wasm module");
            engine.exit = true;
        }
    }

    engine.reload = false;
}

//
// Runtime
//

let boundedRun = () => {};
function run(engine: Engine) {
    if (engine.exit) {
        return;
    }

    update(engine, performance.now());
    render(engine);

    if (engine.reload) {
        reload(engine)
            .then(() => requestAnimationFrame(boundedRun) );
    } else {
        requestAnimationFrame(boundedRun);
    }
}

async function init_app() {
    const engine = await init();
    if (!engine) {
        console.log("Failed to initialize application");
        return;
    }

    boundedRun = run.bind(null, engine);
    boundedRun();
}

init_app();
